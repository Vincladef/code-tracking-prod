name: Daily Reminder Notifications (no Blaze)

on:
  schedule:
    - cron: "0 4 * * *"   # 04:00 UTC ‚âà 06:00 Paris (heure d‚Äô√©t√©)
    - cron: "0 5 * * *"   # 05:00 UTC ‚âà 06:00 Paris (heure d‚Äôhiver)
  workflow_dispatch:       # permet aussi de lancer √† la main

jobs:
  notify:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Admin SDK
        run: |
          npm -y init >/dev/null 2>&1 || true
          npm install firebase-admin@^12

      - name: Send daily reminders (Firestore + FCM + Email)
        env:
          FIREBASE_SERVICE_ACCOUNT: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
          MAIL_CONFIG_JSON: ${{ secrets.MAIL_CONFIG_JSON }}
        run: |
          node - <<'NODE'
          const admin = require("firebase-admin");
          const tls = require('tls');

          // ---- init Admin SDK avec le secret GitHub ----
          const sa = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
          admin.initializeApp({ credential: admin.credential.cert(sa) });
          const db = admin.firestore();
          const messaging = admin.messaging();

          // ---- SMTP settings from MAIL_CONFIG_JSON ----
          let SMTP = null;
          try {
            const raw = process.env.MAIL_CONFIG_JSON;
            if (raw) SMTP = JSON.parse(raw);
          } catch {}

          // ---- helpers date/jour & SR (m√™me logique que ton app) ----
          const DAY_NORMALIZE = { dim:"DIM", lun:"LUN", mar:"MAR", mer:"MER", jeu:"JEU", ven:"VEN", sam:"SAM" };
          const DAY_LABELS = ["DIM","LUN","MAR","MER","JEU","VEN","SAM"];

          function normalizeDay(v){
            if(!v) return null;
            const key = String(v).trim().toLowerCase().replace(/\.$/,'');
            const short = key.slice(0,3);
            return DAY_NORMALIZE[short] || null;
          }
          function toStringOrNull(value, { trim = true } = {}) {
            if (value === undefined || value === null) return null;
            const str = String(value);
            if (!trim) return str;
            const trimmed = str.trim();
            return trimmed.length ? trimmed : null;
          }
          function toDate(v){
            if(!v) return null;
            if(v instanceof Date) return v;
            if(typeof v.toDate === "function"){ try { return v.toDate(); } catch(e){} }
            if(typeof v === "number" || typeof v === "string"){
              const d = new Date(v); if(!Number.isNaN(d.getTime())) return d;
            }
            return null;
          }
          function parisContext(now=new Date()){
            const parisNow = new Date(now.toLocaleString("en-US", { timeZone:"Europe/Paris", hour12:false }));
            const offset = parisNow.getTime() - now.getTime();
            const dayLabel = DAY_LABELS[parisNow.getDay()];
            const hour = parisNow.getHours();
            const midnightLocal = new Date(parisNow); midnightLocal.setHours(0,0,0,0);
            const selectedDate = new Date(midnightLocal.getTime() - offset);
            const year = parisNow.getFullYear();
            const month = String(parisNow.getMonth() + 1).padStart(2, "0");
            const day = String(parisNow.getDate()).padStart(2, "0");
            return { dayLabel, selectedDate, dateIso: `${year}-${month}-${day}`, hour };
          }

          function monthKeyFromDate(date){
            const dt = date instanceof Date ? new Date(date.getTime()) : new Date(date);
            if (Number.isNaN(dt.getTime())) return "";
            return `${dt.getFullYear()}-${String(dt.getMonth() + 1).padStart(2, "0")}`;
          }

          function parseMonthKey(monthKey){
            const [yearStr, monthStr] = String(monthKey || "").split("-");
            const year = Number(yearStr);
            const month = Number(monthStr);
            if (!Number.isFinite(year) || !Number.isFinite(month) || month < 1 || month > 12) return null;
            return { year, month };
          }

          function shiftMonthKey(baseKey, offset){
            if (!Number.isFinite(offset)) return baseKey;
            const parsed = parseMonthKey(baseKey);
            if (!parsed) return baseKey;
            const base = new Date(parsed.year, parsed.month - 1 + offset, 1);
            return monthKeyFromDate(base);
          }

          function normalizedWeekday(value){
            return ((value % 7) + 7) % 7;
          }

          function mondayIndexFromSundayIndex(value){
            return normalizedWeekday(value + 6);
          }

          function weekSegmentDaysInMonth(segment, targetYear, targetMonthIndex){
            if (!segment || !segment.start || !segment.end) return 0;
            let count = 0;
            const cursor = new Date(segment.start.getTime());
            for (let step = 0; step < 7; step += 1){
              if (cursor.getFullYear() === targetYear && cursor.getMonth() === targetMonthIndex){
                count += 1;
              }
              cursor.setDate(cursor.getDate() + 1);
            }
            return count;
          }

          function monthWeekSegments(monthKey){
            const parsed = parseMonthKey(monthKey);
            if (!parsed) return [];
            const { year, month } = parsed;
            const totalDays = new Date(year, month, 0).getDate();
            if (!totalDays) return [];
            const firstDay = new Date(year, month - 1, 1);
            const firstWeekday = mondayIndexFromSundayIndex(firstDay.getDay());
            const baseStartDay = 1 - firstWeekday;
            const rawSegments = [];
            for (let index = 1, startDay = baseStartDay; startDay <= totalDays; index += 1, startDay += 7){
              const endDay = startDay + 6;
              const start = new Date(year, month - 1, startDay);
              const end = new Date(year, month - 1, endDay);
              rawSegments.push({ index, start, end, startDay, endDay });
            }
            const monthIndex = month - 1;
            const filtered = rawSegments.filter(segment => weekSegmentDaysInMonth(segment, year, monthIndex) >= 4);
            if (!filtered.length) return rawSegments;
            return filtered.map((segment, idx) => ({ ...segment, index: idx + 1 }));
          }

          function weekDateRange(monthKey, weekIndex){
            if (!weekIndex) return null;
            const segments = monthWeekSegments(monthKey);
            if (!segments.length) return null;
            const target = segments.find(segment => segment.index === Number(weekIndex));
            if (!target) return null;
            return { start: target.start, end: target.end };
          }

          function theoreticalObjectiveDate(objective){
            const explicitEnd = toDate(objective?.endDate);
            if (explicitEnd){
              explicitEnd.setHours(0,0,0,0);
              return explicitEnd;
            }
            if (objective?.type === "hebdo"){
              const range = weekDateRange(objective.monthKey, objective.weekOfMonth || 1);
              if (range?.end){
                const end = new Date(range.end.getTime());
                end.setHours(0,0,0,0);
                return end;
              }
            }
            if (objective?.type === "mensuel"){
              const parsed = parseMonthKey(objective.monthKey);
              if (parsed){
                const end = new Date(parsed.year, parsed.month, 0);
                end.setHours(0,0,0,0);
                return end;
              }
            }
            const fallback = toDate(objective?.startDate);
            if (fallback){
              fallback.setHours(0,0,0,0);
              return fallback;
            }
            return null;
          }

          function customObjectiveReminderDate(objective){
            if (!objective) return null;
            const raw = objective.notifyAt ?? objective.notifyDate ?? objective.notificationDate ?? null;
            const customDate = toDate(raw);
            if (!customDate) return null;
            const { selectedDate, dateIso } = parisContext(customDate);
            return { selectedDate, dateIso };
          }

          function objectiveDueDateIso(objective){
            if (!objective) return null;
            const custom = customObjectiveReminderDate(objective);
            if (custom?.dateIso) return custom.dateIso;
            const theoretical = theoreticalObjectiveDate(objective);
            if (!theoretical) return null;
            const { dateIso } = parisContext(theoretical);
            return dateIso;
          }

          async function fetchObjectivesByMonth(uid, monthKey){
            if (!uid || !monthKey) return [];
            try {
              const snap = await db.collection("u").doc(uid).collection("objectifs").where("monthKey", "==", monthKey).get();
              return snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } catch (error) {
              console.warn("fetchObjectivesByMonth:error", { uid, monthKey, error: error?.message });
              return [];
            }
          }

          async function fetchObjectivesByReminder(uid, dateIso, fields = ["notifyAt", "notifyDate", "notificationDate"]){
            if (!uid || !dateIso) return [];
            const collectionRef = db.collection("u").doc(uid).collection("objectifs");
            const seen = new Set();
            const objectives = [];
            await Promise.all(fields.map(async field => {
              try {
                const snap = await collectionRef.where(field, "==", dateIso).get();
                snap.forEach(doc => {
                  if (seen.has(doc.id)) return;
                  seen.add(doc.id);
                  objectives.push({ id: doc.id, ...doc.data() });
                });
              } catch (error) {
                console.warn("fetchObjectivesByReminder:error", { uid, field, dateIso, error: error?.message });
              }
            }));
            return objectives;
          }

          async function countObjectivesDueToday(uid, context){
            const baseMonthKey = toStringOrNull(context?.dateIso)?.slice(0,7);
            const monthKey = baseMonthKey || monthKeyFromDate(context.selectedDate);
            const previousMonth = monthKey ? shiftMonthKey(monthKey, -1) : null;
            const targetMonths = new Set();
            if (monthKey) targetMonths.add(monthKey);
            if (previousMonth && previousMonth !== monthKey) targetMonths.add(previousMonth);

            const objectiveMap = new Map();

            for (const key of targetMonths){
              const rows = await fetchObjectivesByMonth(uid, key);
              for (const row of rows){
                if (!row || !row.id) continue;
                objectiveMap.set(row.id, row);
              }
            }

            const reminderIso = toStringOrNull(context?.dateIso);
            if (reminderIso){
              const reminderRows = await fetchObjectivesByReminder(uid, reminderIso);
              for (const row of reminderRows){
                if (!row || !row.id) continue;
                objectiveMap.set(row.id, row);
              }
            }

            const objectives = Array.from(objectiveMap.values());
            let count = 0;
            for (const objective of objectives){
              if (objective?.notifyOnTarget === false) continue;
              const iso = objectiveDueDateIso(objective);
              if (!iso) continue;
              if (iso === context.dateIso) count += 1;
            }
            return count;
          }

          function pluralize(count, singular, plural = null){
            if (count === 1) return singular;
            return plural || `${singular}s`;
          }

          function buildReminderBody(firstName, consigneCount, objectiveCount){
            const prefix = firstName ? `${firstName}, ` : "";
            if (consigneCount === 0 && objectiveCount === 0){
              return `${prefix}tu n‚Äôas rien √† remplir aujourd‚Äôhui.`;
            }
            const objectiveLabel = pluralize(objectiveCount, "objectif");
            if (consigneCount === 0){
              return `${prefix}tu as ${objectiveCount} ${objectiveLabel} √† remplir aujourd‚Äôhui.`;
            }
            const consigneLabel = pluralize(consigneCount, "consigne");
            return `${prefix}tu as ${consigneCount} ${consigneLabel} et ${objectiveCount} ${objectiveLabel} √† remplir aujourd‚Äôhui.`;
          }

          function extractFirstName(profile = {}){
            const raw = String(profile.name || profile.displayName || "").trim();
            if (!raw) return "";
            const parts = raw.split(/\s+/).filter(Boolean);
            if (!parts.length) return "";
            return parts[0];
          }

          function extractEmailList(profile){
            const source = profile && typeof profile === 'object' ? profile : {};
            const seen = new Set();
            const emails = [];
            const push = (v)=>{ const e = (v==null?null:String(v).trim()); if(!e) return; const k=e.toLowerCase(); if(seen.has(k)) return; seen.add(k); emails.push(e); };
            if (Array.isArray(source.emails)) source.emails.forEach(push);
            push(source.email);
            return emails;
          }

          function isInvalidToken(code){
            return code === "messaging/registration-token-not-registered" ||
                   code === "messaging/invalid-registration-token";
          }
          async function disableToken(uid, token){
            try{
              await db.doc(`u/${uid}/pushTokens/${token}`).set(
                { enabled:false, updatedAt: admin.firestore.FieldValue.serverTimestamp() },
                { merge:true }
              );
            }catch(e){ console.error("disableToken", uid, token, e.message); }
          }

          async function collectTokensByUid(){
            const snap = await db.collectionGroup("pushTokens").get();
            const map = new Map();
            for(const doc of snap.docs){
              const data = doc.data() || {};
              if (data.enabled === false) continue;
              const token = data.token || doc.id;
              if (!token) continue;
              const parent = doc.ref.parent && doc.ref.parent.parent;
              const uid = parent && parent.id;
              if (!uid) continue;
              if (!map.has(uid)) map.set(uid, new Set());
              map.get(uid).add(token);
            }
            return map;
          }

          async function countVisibleDaily(uid, ctx){
            const consSnap = await db.collection("u").doc(uid).collection("consignes")
              .where("mode","==","daily").get();
            if (consSnap.empty) return 0;

            const consignes = consSnap.docs
              .map(d => ({ id: d.id, data: d.data() || {} }))
              .filter(x => x.data.active !== false);
            if (!consignes.length) return 0;

            const needsSr = consignes.some(x => x.data.srEnabled !== false);
            const sr = new Map();
            if (needsSr){
              const srSnap = await db.collection("u").doc(uid).collection("sr").get();
              for(const d of srSnap.docs){
                if (!d.id.startsWith("consigne:")) continue;
                sr.set(d.id.slice("consigne:".length), d.data() || {});
              }
            }

            let visible = 0;
            for (const item of consignes){
              const { id, data } = item;
              const days = Array.isArray(data.days) ? data.days.map(normalizeDay).filter(Boolean) : [];
              if (days.length && !days.includes(ctx.dayLabel)) continue;

              if (data.srEnabled === false){ visible++; continue; }
              const s = sr.get(id);
              if (!s){ visible++; continue; }
              const nextDate = toDate(s.nextVisibleOn || s.hideUntil);
              if (!nextDate || nextDate <= ctx.selectedDate) visible++;
            }
            return visible;
          }

          async function main(){
            const ctx = parisContext();
            const eventName = process.env.GITHUB_EVENT_NAME;
            const isManual = eventName === "workflow_dispatch";

            if (ctx.hour !== 6 && !isManual){
              console.log(`skip run: current Paris hour = ${ctx.hour}`);
              return;
            }
            if (ctx.hour !== 6 && isManual){
              console.log(`manual override: event=${eventName}, current Paris hour = ${ctx.hour}`);
            }
            console.log("context", { ...ctx, selectedDateUtc: ctx.selectedDate?.toISOString?.() });
            const tokensByUid = await collectTokensByUid();

            let totalSent = 0;
            const emailResults = [];
            for (const [uid, tokSet] of tokensByUid.entries()){
              const tokens = Array.from(tokSet);
              const visibleCount = await countVisibleDaily(uid, ctx);
              const objectiveCount = await countObjectivesDueToday(uid, ctx);
              if (visibleCount < 1 && objectiveCount < 1) {
                console.log(`skip uid=${uid} reason=no_visible_items,no_objectives`);
                continue;
              }

              const profSnap = await db.doc(`u/${uid}`).get();
              const prof = profSnap.exists ? (profSnap.data() || {}) : {};
              const firstName = extractFirstName(prof);
              const profileEmails = extractEmailList(prof);
              const userName = prof.name || prof.displayName || prof.slug || "toi";
              const title = firstName ? `${firstName}, rappel du jour üëã` : "Rappel du jour üëã";
              const body = buildReminderBody(firstName, visibleCount, objectiveCount);
              const link = "https://vincladef.github.io/code-tracking-prod/#/daily";

              const message = {
                tokens,
                notification: {
                  title,
                  body
                },
                webpush: {
                  fcmOptions: { link }
                },
                data: {
                  user: String(userName),
                  firstName: String(firstName || ""),
                  count: String(visibleCount),
                  consignes: String(visibleCount),
                  objectifs: String(objectiveCount),
                  day: ctx.dayLabel,
                  body,
                  title,
                  link
                }
              };

              const res = await messaging.sendEachForMulticast(message);
              totalSent += res.successCount;
              res.responses.forEach((r, i) => {
                if (!r.success && isInvalidToken(r.error && r.error.code)) {
                  disableToken(uid, tokens[i]);
                }
              });
              console.log(`uid=${uid} -> sent=${res.successCount}, failed=${res.failureCount}, visible=${visibleCount}, objectives=${objectiveCount}`);

              // ---- Email (si config SMTP et au moins un objectif) ----
              if (SMTP && Array.isArray(profileEmails) && profileEmails.length && objectiveCount > 0){
                try {
                  const { subject, text, html } = (function buildGoalReminderEmail(){
                    const dateLabel = new Date().toLocaleDateString('fr-FR',{ weekday:'long', day:'numeric', month:'long', year:'numeric' });
                    const formatted = dateLabel.charAt(0).toUpperCase()+dateLabel.slice(1);
                    const subject = (objectiveCount>1? 'Rappel objectifs' : 'Rappel objectif') + ' ‚Äî ' + formatted;
                    const greeting = firstName? `Bonjour ${firstName},` : 'Bonjour,';
                    const intro = objectiveCount>1? `Voici tes objectifs √† r√©aliser le ${formatted} :` : `Voici ton objectif √† r√©aliser le ${formatted} :`;
                    const lines=[greeting,'',intro,`- ${objectiveCount} objectif(s)`, '', `Acc√®de √† ton espace : ${link}`,'','Bonne journ√©e !'];
                    const text = lines.join('\n');
                    const html = [`<p>${greeting}</p>`,`<p>${intro}</p>`,`<ul><li>${objectiveCount} objectif(s)</li></ul>`,`<p><a href="${link}">Ouvrir mon suivi</a></p>`].join('');
                    return { subject, text, html };
                  })();

                  // Minimal SMTP client (LOGIN) comme dans functions/index.js
                  await (async function send(){
                    const recipients = profileEmails;
                    const socket = await new Promise((resolve, reject) => {
                      const c = tls.connect({ host: SMTP.host, port: Number(SMTP.port)||465, rejectUnauthorized: true }, () => { c.setEncoding('utf8'); c.removeListener('error', onErr); resolve(c); });
                      const onErr = (e)=>reject(e); c.once('error', onErr);
                    });
                    const wait = ()=> new Promise((res,rej)=>{ let buf=''; const onData=(ch)=>{ buf+=ch.toString(); const lines=buf.split(/\r?\n/).filter(Boolean); if(!lines.length) return; const last=lines[lines.length-1]; const m=last.match(/^(\d{3})([ -])/); if(!m) return; if(m[2]==='-') return; socket.removeListener('data',onData); res({ code:Number(m[1]), lines});}; const onErr=(e)=>{ socket.removeListener('data',onData); rej(e);}; socket.on('data',onData); socket.on('error',onErr); });
                    const send = async (cmd, allow=[])=>{ socket.write(cmd+'\r\n'); const r=await wait(); if (!(r.code<400 && (!allow.length || allow.includes(r.code)))) throw new Error('SMTP failed '+cmd+' => '+r.code); return r; };
                    await wait();
                    await send(`EHLO ${SMTP.host}`);
                    if (SMTP.user && SMTP.pass){ await send('AUTH LOGIN',[334]); await send(Buffer.from(SMTP.user).toString('base64'),[334]); await send(Buffer.from(SMTP.pass).toString('base64'),[235]); }
                    await send(`MAIL FROM:<${SMTP.from}>`);
                    for (const r of recipients){ await send(`RCPT TO:<${r}>`,[250,251]); }
                    await send('DATA',[354]);
                    const boundary = '=_gh_'+Date.now();
                    const headers = [
                      `From: ${SMTP.from}`,
                      `To: ${recipients.join(', ')}`,
                      `Subject: ${subject}`,
                      'MIME-Version: 1.0',
                      `Content-Type: multipart/alternative; boundary="${boundary}"`,
                      `Date: ${new Date().toUTCString()}`
                    ];
                    const parts = [
                      `--${boundary}\r\nContent-Type: text/plain; charset=utf-8\r\nContent-Transfer-Encoding: 8bit\r\n\r\n${text}\r\n`,
                      `--${boundary}\r\nContent-Type: text/html; charset=utf-8\r\nContent-Transfer-Encoding: 8bit\r\n\r\n${html}\r\n`,
                      `--${boundary}--\r\n`
                    ];
                    socket.write(headers.join('\r\n')+'\r\n\r\n'+parts.join('')+'\r\n.\r\n');
                    const final = await wait();
                    if (final.code>=400) throw new Error('SMTP delivery failed '+final.code);
                    await send('QUIT',[221]);
                    socket.end();
                  })();
                  emailResults.push({ uid, to: profileEmails, ok: true });
                  console.log(`email uid=${uid} -> to=${profileEmails.join(',')}`);
                } catch(e){
                  emailResults.push({ uid, ok: false, error: e?.message });
                  console.error('email error uid='+uid, e?.message);
                }
              }
            }
            console.log("done: push sent", totalSent);
          }

          main().catch(e => { console.error("fatal", e); process.exit(1); });
          NODE
