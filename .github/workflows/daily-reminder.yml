name: Daily Reminder Notifications (no Blaze)

on:
  schedule:
    - cron: "0 4 * * *"   # 04:00 UTC â‰ˆ 06:00 Paris (heure dâ€™Ã©tÃ©)
    - cron: "0 5 * * *"   # 05:00 UTC â‰ˆ 06:00 Paris (heure dâ€™hiver)
  workflow_dispatch:       # permet aussi de lancer Ã  la main

jobs:
  notify:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Admin SDK
        run: |
          npm -y init >/dev/null 2>&1 || true
          npm install firebase-admin@^12

      - name: Send daily reminders (Firestore + FCM)
        env:
          FIREBASE_SERVICE_ACCOUNT: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
        run: |
          node - <<'NODE'
          const admin = require("firebase-admin");

          // ---- init Admin SDK avec le secret GitHub ----
          const sa = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
          admin.initializeApp({ credential: admin.credential.cert(sa) });
          const db = admin.firestore();
          const messaging = admin.messaging();

          // ---- helpers date/jour & SR (mÃªme logique que ton app) ----
          const DAY_NORMALIZE = { dim:"DIM", lun:"LUN", mar:"MAR", mer:"MER", jeu:"JEU", ven:"VEN", sam:"SAM" };
          const DAY_LABELS = ["DIM","LUN","MAR","MER","JEU","VEN","SAM"];

          function normalizeDay(v){
            if(!v) return null;
            const key = String(v).trim().toLowerCase().replace(/\.$/,'');
            const short = key.slice(0,3);
            return DAY_NORMALIZE[short] || null;
          }
          function toStringOrNull(value, { trim = true } = {}) {
            if (value === undefined || value === null) return null;
            const str = String(value);
            if (!trim) return str;
            const trimmed = str.trim();
            return trimmed.length ? trimmed : null;
          }
          function toDate(v){
            if(!v) return null;
            if(v instanceof Date) return v;
            if(typeof v.toDate === "function"){ try { return v.toDate(); } catch(e){} }
            if(typeof v === "number" || typeof v === "string"){
              const d = new Date(v); if(!Number.isNaN(d.getTime())) return d;
            }
            return null;
          }
          function parisContext(now=new Date()){
            const parisNow = new Date(now.toLocaleString("en-US", { timeZone:"Europe/Paris", hour12:false }));
            const offset = parisNow.getTime() - now.getTime();
            const dayLabel = DAY_LABELS[parisNow.getDay()];
            const hour = parisNow.getHours();
            const midnightLocal = new Date(parisNow); midnightLocal.setHours(0,0,0,0);
            const selectedDate = new Date(midnightLocal.getTime() - offset);
            return { dayLabel, selectedDate, dateIso: selectedDate.toISOString().slice(0,10), hour };
          }

          function monthKeyFromDate(date){
            const dt = date instanceof Date ? new Date(date.getTime()) : new Date(date);
            if (Number.isNaN(dt.getTime())) return "";
            return `${dt.getFullYear()}-${String(dt.getMonth() + 1).padStart(2, "0")}`;
          }

          function parseMonthKey(monthKey){
            const [yearStr, monthStr] = String(monthKey || "").split("-");
            const year = Number(yearStr);
            const month = Number(monthStr);
            if (!Number.isFinite(year) || !Number.isFinite(month) || month < 1 || month > 12) return null;
            return { year, month };
          }

          function shiftMonthKey(baseKey, offset){
            if (!Number.isFinite(offset)) return baseKey;
            const parsed = parseMonthKey(baseKey);
            if (!parsed) return baseKey;
            const base = new Date(parsed.year, parsed.month - 1 + offset, 1);
            return monthKeyFromDate(base);
          }

          function normalizedWeekday(value){
            return ((value % 7) + 7) % 7;
          }

          function mondayIndexFromSundayIndex(value){
            return normalizedWeekday(value + 6);
          }

          function weekSegmentDaysInMonth(segment, targetYear, targetMonthIndex){
            if (!segment || !segment.start || !segment.end) return 0;
            let count = 0;
            const cursor = new Date(segment.start.getTime());
            for (let step = 0; step < 7; step += 1){
              if (cursor.getFullYear() === targetYear && cursor.getMonth() === targetMonthIndex){
                count += 1;
              }
              cursor.setDate(cursor.getDate() + 1);
            }
            return count;
          }

          function monthWeekSegments(monthKey){
            const parsed = parseMonthKey(monthKey);
            if (!parsed) return [];
            const { year, month } = parsed;
            const totalDays = new Date(year, month, 0).getDate();
            if (!totalDays) return [];
            const firstDay = new Date(year, month - 1, 1);
            const firstWeekday = mondayIndexFromSundayIndex(firstDay.getDay());
            const baseStartDay = 1 - firstWeekday;
            const rawSegments = [];
            for (let index = 1, startDay = baseStartDay; startDay <= totalDays; index += 1, startDay += 7){
              const endDay = startDay + 6;
              const start = new Date(year, month - 1, startDay);
              const end = new Date(year, month - 1, endDay);
              rawSegments.push({ index, start, end, startDay, endDay });
            }
            const monthIndex = month - 1;
            const filtered = rawSegments.filter(segment => weekSegmentDaysInMonth(segment, year, monthIndex) >= 4);
            if (!filtered.length) return rawSegments;
            return filtered.map((segment, idx) => ({ ...segment, index: idx + 1 }));
          }

          function weekDateRange(monthKey, weekIndex){
            if (!weekIndex) return null;
            const segments = monthWeekSegments(monthKey);
            if (!segments.length) return null;
            const target = segments.find(segment => segment.index === Number(weekIndex));
            if (!target) return null;
            return { start: target.start, end: target.end };
          }

          function theoreticalObjectiveDate(objective){
            const explicitEnd = toDate(objective?.endDate);
            if (explicitEnd){
              explicitEnd.setHours(0,0,0,0);
              return explicitEnd;
            }
            if (objective?.type === "hebdo"){
              const range = weekDateRange(objective.monthKey, objective.weekOfMonth || 1);
              if (range?.end){
                const end = new Date(range.end.getTime());
                end.setHours(0,0,0,0);
                return end;
              }
            }
            if (objective?.type === "mensuel"){
              const parsed = parseMonthKey(objective.monthKey);
              if (parsed){
                const end = new Date(parsed.year, parsed.month, 0);
                end.setHours(0,0,0,0);
                return end;
              }
            }
            const fallback = toDate(objective?.startDate);
            if (fallback){
              fallback.setHours(0,0,0,0);
              return fallback;
            }
            return null;
          }

          function customObjectiveReminderDate(objective){
            if (!objective) return null;
            const raw = objective.notifyAt ?? objective.notifyDate ?? objective.notificationDate ?? null;
            const customDate = toDate(raw);
            if (!customDate) return null;
            const { selectedDate, dateIso } = parisContext(customDate);
            return { selectedDate, dateIso };
          }

          function objectiveDueDateIso(objective){
            if (!objective) return null;
            const custom = customObjectiveReminderDate(objective);
            if (custom?.dateIso) return custom.dateIso;
            const theoretical = theoreticalObjectiveDate(objective);
            if (!theoretical) return null;
            const { dateIso } = parisContext(theoretical);
            return dateIso;
          }

          async function fetchObjectivesByMonth(uid, monthKey){
            if (!uid || !monthKey) return [];
            try {
              const snap = await db.collection("u").doc(uid).collection("objectifs").where("monthKey", "==", monthKey).get();
              return snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } catch (error) {
              console.warn("fetchObjectivesByMonth:error", { uid, monthKey, error: error?.message });
              return [];
            }
          }

          async function fetchObjectivesByReminder(uid, dateIso, fields = ["notifyAt", "notifyDate", "notificationDate"]){
            if (!uid || !dateIso) return [];
            const collectionRef = db.collection("u").doc(uid).collection("objectifs");
            const seen = new Set();
            const objectives = [];
            await Promise.all(fields.map(async field => {
              try {
                const snap = await collectionRef.where(field, "==", dateIso).get();
                snap.forEach(doc => {
                  if (seen.has(doc.id)) return;
                  seen.add(doc.id);
                  objectives.push({ id: doc.id, ...doc.data() });
                });
              } catch (error) {
                console.warn("fetchObjectivesByReminder:error", { uid, field, dateIso, error: error?.message });
              }
            }));
            return objectives;
          }

          async function countObjectivesDueToday(uid, context){
            const baseMonthKey = toStringOrNull(context?.dateIso)?.slice(0,7);
            const monthKey = baseMonthKey || monthKeyFromDate(context.selectedDate);
            const previousMonth = monthKey ? shiftMonthKey(monthKey, -1) : null;
            const targetMonths = new Set();
            if (monthKey) targetMonths.add(monthKey);
            if (previousMonth && previousMonth !== monthKey) targetMonths.add(previousMonth);

            const objectiveMap = new Map();

            for (const key of targetMonths){
              const rows = await fetchObjectivesByMonth(uid, key);
              for (const row of rows){
                if (!row || !row.id) continue;
                objectiveMap.set(row.id, row);
              }
            }

            const reminderIso = toStringOrNull(context?.dateIso);
            if (reminderIso){
              const reminderRows = await fetchObjectivesByReminder(uid, reminderIso);
              for (const row of reminderRows){
                if (!row || !row.id) continue;
                objectiveMap.set(row.id, row);
              }
            }

            const objectives = Array.from(objectiveMap.values());
            let count = 0;
            for (const objective of objectives){
              if (objective?.notifyOnTarget === false) continue;
              const iso = objectiveDueDateIso(objective);
              if (!iso) continue;
              if (iso === context.dateIso) count += 1;
            }
            return count;
          }

          function pluralize(count, singular, plural = null){
            if (count === 1) return singular;
            return plural || `${singular}s`;
          }

          function buildReminderBody(firstName, consigneCount, objectiveCount){
            const prefix = firstName ? `${firstName}, ` : "";
            if (consigneCount === 0 && objectiveCount === 0){
              return `${prefix}tu nâ€™as rien Ã  remplir aujourdâ€™hui.`;
            }
            const objectiveLabel = pluralize(objectiveCount, "objectif");
            if (consigneCount === 0){
              return `${prefix}tu as ${objectiveCount} ${objectiveLabel} Ã  remplir aujourdâ€™hui.`;
            }
            const consigneLabel = pluralize(consigneCount, "consigne");
            return `${prefix}tu as ${consigneCount} ${consigneLabel} et ${objectiveCount} ${objectiveLabel} Ã  remplir aujourdâ€™hui.`;
          }

          function extractFirstName(profile = {}){
            const raw = String(profile.name || profile.displayName || "").trim();
            if (!raw) return "";
            const parts = raw.split(/\s+/).filter(Boolean);
            if (!parts.length) return "";
            return parts[0];
          }

          function isInvalidToken(code){
            return code === "messaging/registration-token-not-registered" ||
                   code === "messaging/invalid-registration-token";
          }
          async function disableToken(uid, token){
            try{
              await db.doc(`u/${uid}/pushTokens/${token}`).set(
                { enabled:false, updatedAt: admin.firestore.FieldValue.serverTimestamp() },
                { merge:true }
              );
            }catch(e){ console.error("disableToken", uid, token, e.message); }
          }

          async function collectTokensByUid(){
            const snap = await db.collectionGroup("pushTokens").get();
            const map = new Map();
            for(const doc of snap.docs){
              const data = doc.data() || {};
              if (data.enabled === false) continue;
              const token = data.token || doc.id;
              if (!token) continue;
              const parent = doc.ref.parent && doc.ref.parent.parent;
              const uid = parent && parent.id;
              if (!uid) continue;
              if (!map.has(uid)) map.set(uid, new Set());
              map.get(uid).add(token);
            }
            return map;
          }

          async function countVisibleDaily(uid, ctx){
            const consSnap = await db.collection("u").doc(uid).collection("consignes")
              .where("mode","==","daily").get();
            if (consSnap.empty) return 0;

            const consignes = consSnap.docs
              .map(d => ({ id: d.id, data: d.data() || {} }))
              .filter(x => x.data.active !== false);
            if (!consignes.length) return 0;

            const needsSr = consignes.some(x => x.data.srEnabled !== false);
            const sr = new Map();
            if (needsSr){
              const srSnap = await db.collection("u").doc(uid).collection("sr").get();
              for(const d of srSnap.docs){
                if (!d.id.startsWith("consigne:")) continue;
                sr.set(d.id.slice("consigne:".length), d.data() || {});
              }
            }

            let visible = 0;
            for (const item of consignes){
              const { id, data } = item;
              const days = Array.isArray(data.days) ? data.days.map(normalizeDay).filter(Boolean) : [];
              if (days.length && !days.includes(ctx.dayLabel)) continue;

              if (data.srEnabled === false){ visible++; continue; }
              const s = sr.get(id);
              if (!s){ visible++; continue; }
              const nextDate = toDate(s.nextVisibleOn || s.hideUntil);
              if (!nextDate || nextDate <= ctx.selectedDate) visible++;
            }
            return visible;
          }

          async function main(){
            const ctx = parisContext();
            const eventName = process.env.GITHUB_EVENT_NAME;
            const isManual = eventName === "workflow_dispatch";

            if (ctx.hour !== 6 && !isManual){
              console.log(`skip run: current Paris hour = ${ctx.hour}`);
              return;
            }
            if (ctx.hour !== 6 && isManual){
              console.log(`manual override: event=${eventName}, current Paris hour = ${ctx.hour}`);
            }
            console.log("context", ctx);
            const tokensByUid = await collectTokensByUid();

            let totalSent = 0;
            for (const [uid, tokSet] of tokensByUid.entries()){
              const tokens = Array.from(tokSet);
              const visibleCount = await countVisibleDaily(uid, ctx);
              const objectiveCount = await countObjectivesDueToday(uid, ctx);
              if (visibleCount < 1 && objectiveCount < 1) {
                console.log(`skip uid=${uid} reason=no_visible_items,no_objectives`);
                continue;
              }

              const profSnap = await db.doc(`u/${uid}`).get();
              const prof = profSnap.exists ? (profSnap.data() || {}) : {};
              const firstName = extractFirstName(prof);
              const userName = prof.name || prof.displayName || prof.slug || "toi";
              const title = firstName ? `${firstName}, rappel du jour ðŸ‘‹` : "Rappel du jour ðŸ‘‹";
              const body = buildReminderBody(firstName, visibleCount, objectiveCount);
              const link = "https://vincladef.github.io/code-tracking-prod/#/daily";

              const message = {
                tokens,
                notification: {
                  title,
                  body
                },
                webpush: {
                  fcmOptions: { link }
                },
                data: {
                  user: String(userName),
                  firstName: String(firstName || ""),
                  count: String(visibleCount),
                  consignes: String(visibleCount),
                  objectifs: String(objectiveCount),
                  day: ctx.dayLabel,
                  body,
                  title,
                  link
                }
              };

              const res = await messaging.sendEachForMulticast(message);
              totalSent += res.successCount;
              res.responses.forEach((r, i) => {
                if (!r.success && isInvalidToken(r.error && r.error.code)) {
                  disableToken(uid, tokens[i]);
                }
              });
              console.log(`uid=${uid} -> sent=${res.successCount}, failed=${res.failureCount}, visible=${visibleCount}, objectives=${objectiveCount}`);
            }
            console.log("done: sent", totalSent);
          }

          main().catch(e => { console.error("fatal", e); process.exit(1); });
          NODE
